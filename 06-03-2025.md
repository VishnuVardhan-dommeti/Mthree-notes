# Python Object-Oriented Programming (OOP) Guide

## Table of Contents
1. [Introduction](#introduction)
2. [Basic Class Definition and Objects](#basic-class-definition-and-objects)
3. [Inheritance](#inheritance)
4. [Encapsulation](#encapsulation)
5. [Polymorphism](#polymorphism)
6. [Abstraction](#abstraction)
7. [Properties and Descriptors](#properties-and-descriptors)
8. [Class and Static Methods](#class-and-static-methods)
9. [Magic Methods (Dunder Methods)](#magic-methods-dunder-methods)
10. [Metaclasses](#metaclasses)
11. [Advanced Design Patterns](#advanced-design-patterns)

---

## Introduction
Object-Oriented Programming (OOP) is a paradigm that organizes code using objects and classes. It helps in structuring complex programs by encapsulating related properties and behaviors into objects. This approach improves code reusability, scalability, and maintainability. 

In Python, OOP is implemented using **classes and objects**. A class defines a blueprint, and an object is an instance of that blueprint. This guide will cover all OOP concepts in Python with real-world analogies, explanations, and code examples.

---

## Inheritance
### What is Inheritance?
**Inheritance** is one of the key principles of OOP that allows a class (child class) to acquire the properties and behaviors of another class (parent class). This promotes code reusability and hierarchical relationships between classes.

### Why Use Inheritance?
- Reduces code duplication
- Establishes relationships between classes
- Enhances code maintainability

### Types of Inheritance:
1. **Single Inheritance:** A child class inherits from one parent class.
2. **Multiple Inheritance:** A child class inherits from more than one parent class.
3. **Multilevel Inheritance:** A class inherits from another class, which in turn inherits from another class.
4. **Hierarchical Inheritance:** Multiple child classes inherit from a single parent class.
5. **Hybrid Inheritance:** A combination of multiple types of inheritance.

### Example: Single Inheritance
```python
class Animal:
    def __init__(self, name):
        self.name = name
    
    def speak(self):
        return "Animal sound"

class Dog(Animal):
    def speak(self):
        return "Bark"

# Creating an instance
dog = Dog("Buddy")
print(dog.name)   # Output: Buddy
print(dog.speak())  # Output: Bark
```

### Example: Multiple Inheritance
```python
class Flyer:
    def fly(self):
        return "I can fly"

class Swimmer:
    def swim(self):
        return "I can swim"

class Duck(Flyer, Swimmer):
    pass

duck = Duck()
print(duck.fly())  # Output: I can fly
print(duck.swim())  # Output: I can swim
```

### Example: Multilevel Inheritance
```python
class Animal:
    def breathe(self):
        return "Breathing"

class Mammal(Animal):
    def feed_milk(self):
        return "Feeding milk"

class Dog(Mammal):
    def bark(self):
        return "Barking"

dog = Dog()
print(dog.breathe())  # Output: Breathing
print(dog.feed_milk())  # Output: Feeding milk
print(dog.bark())  # Output: Barking
```

---

## Polymorphism
### What is Polymorphism?
Polymorphism allows different classes to be treated as instances of the same class through a common interface. This makes the code more flexible and scalable.

### Why Use Polymorphism?
- Allows different objects to share the same interface
- Makes code more generic and reusable
- Enhances flexibility in code implementation

### Example: Method Overriding (Runtime Polymorphism)
```python
class Animal:
    def speak(self):
        return "Animal makes a sound"

class Dog(Animal):
    def speak(self):
        return "Bark"

class Cat(Animal):
    def speak(self):
        return "Meow"

def animal_sound(animal):
    return animal.speak()

animals = [Dog(), Cat()]
for animal in animals:
    print(animal_sound(animal))
# Output:
# Bark
# Meow
```

### Example: Method Overloading (Compile-time Polymorphism in Other Languages)
Python does not support traditional method overloading, but we can achieve similar behavior using default arguments.
```python
class Math:
    def add(self, a, b, c=None):
        if c is not None:
            return a + b + c
        return a + b

math = Math()
print(math.add(2, 3))  # Output: 5
print(math.add(2, 3, 4))  # Output: 9
```

### Example: Operator Overloading
Polymorphism can also be implemented using **magic methods (dunder methods)** to overload operators.
```python
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y)
    
    def __str__(self):
        return f"Vector({self.x}, {self.y})"

v1 = Vector(2, 3)
v2 = Vector(4, 5)
v3 = v1 + v2
print(v3)  # Output: Vector(6, 8)
```

---

This documentation now provides **in-depth coverage of Inheritance and Polymorphism**, explaining various types with extensive examples and use cases. ðŸš€

